- Idris compiles now, but Idris itself fails to compile its libraries, with
  lots of error messages.
  - Turn on logging, as a first step to figuring things out?
  - Save the normal error output too?

- Now working on adapting the elabArgs stuff from the old branch, and getting
  big doubts again whether I sufficiently understand what's going on with the
  hole name switching in 'apply' and how that might affect things.
  - What is actually *done* with the modified hole names in the original
    elabArgs?
    - There's at least one other bit, but one thing is that apparently we
      *skip* elaboration of arguments if the hole name isn't among 'holes' of
      the ProofState!
      - When would that happen? Does this have specifically to do with the
        odd switcheroo in 'apply'?
      - And *why* is this done?
      - Should I try to respect this procedure? By which I mean..?
        - By which I mean to assume that the skipping is OK and will not
          concern any holes that I'm trying to deal with, and possibly also, in
          that case, it would also not matter w.r.t. translateDefaults that
          some of the names are weird?
          - If the funny names are not among 'holes', then presumably they will
            also not get solved off beneath our feet..?
          - Might it be the case (wishful thinking, here..) that it *wouldn't
            matter* which set of names I use in translateDefaults?
            - Hm hm hm I'm definitely leaning on using the original ones. They
              should be the ones that match the actual proof term, which is
              what governs how the actual substitution happens once the holes
              are solved, no?
          - Now, should I assume that the 'weird' holes won't be ones that have
            my actual default arguments (and I mean the arguments themselves,
            not the possibly referenced other previous arguments)?
            - Could I actually figure that out by looking at form of the
              relevant data, the 'P foo bar' or somesuch stuff?
            - Actually I have something of a hunch that they indeed won't be,
              since those (*afaiu*) shouldn't end up among 'unify', which would
              be what triggers the weirdness.
              - I'll want to check, though, whether I actually had some changes
                in something like insertImpl that was needed to ensure that I
                don't have placeholders in places where I shouldn't have
                placeholders lest it would actually cause such an above
                alluded misfortune.
                - Though maybe that was a thing in the ill-fated
                  'lift-placeholders' branch.
                  - No, well, it seems to still be present in the first 'new
                    wip' branch, although it actually comes with a FIXME note
                    questioning its necessity. (!)
    - Do the hole names actually coordinate in any way with the actual args
      there?
      - I suppose, in the sense that if a hole name isn't in 'holes', the
        'corresponding' argument doesn't get elaborated.

- Now:
  - Actually add 'defer_solve' to ProofState.
  - Actually write into 'defer_solve' in apply_defer.
  - Make so that deferrals are released once args are elaborated.
    - What the heck to think about the hole name switcheroo on the 'apply'
      return value? D: (!?)
      - I just added it as an extra element and adapted the normal 'apply'
        functions to drop that element in their own return values.
|
- (And, then, adapt translateDefaults stuff etc. from the old branch.) (!)

- So..?
  - Add 'defer_solve' to ProofState?
  - Manage 'defer_solve' together with 'dontunify' somehow?
  |
  - How, precisely, do we want to ensure that 'defer_solve'd holes are kept
    from being solved?
    - Is this to be independent of 'unified' and 'notunified'?
      - Need to take a look once again at how end_unify and others decide
        things. Need to keep taking looks, probably.
      - I guess 'notunified' at least shouldn't have anything to do with this.
    - Probably a good way to get clarity would indeed be to look at all the
      places where 'dontunify' is inspected. (!!)
    |
    - Things probably won't be so simple as merely concatenating 'defer_solve'
      to things like 'let dont = dontunify' at all the use sites. In at least
      some cases it seems like such 'dont's are used also for stuff I don't
      want for defer_solve, such as adding to stuff to be added to
      'notunified'. So presumably I'll want to do something like have a
      'let defer = defer_solve p' and then use a lot of 'dont ++ defer'. (!)
  - 'updateProblems' call site in 'processTactic UnifyProblems'. What to do
    here, for example? Should I 'defer_solve' stuff in 'problems'?
    - Some possible reasoning: Will it not be the case that we end up with
      'problems' only once we've *tried* to unify? And we won't have tried
      on holes that are still deferred? (!?)
  - Do we need to touch 'patvar' in ProofState.hs? (!?)
  - unify' is a bit of a puzzle. Look at use sites to see whether we should
    defer_solve things there. (!)
    - Doesn't seem to be associated with anything undesireable.
|
- Preliminary side note: How, precisely, will we know what to remove from
  'defer_solve' once we've elaborated args?
  - The return value from 'apply_defer'? Hopefully it indeed will be trust-
    worthy.

- One option (in the relevant scenario) might be to leave the argument hole
  names out of ProofState.holes entirely, until all the arguments have been
  elaborated.
  - That'd probably be too weird.

- I already thought of this way back, and think I did write it down somewhere,
  but I'll note again that I might need to extend the mechanism of 'deferring
  solving' (cf. 'dontunify') to *all argument holes* that default argument
  insertion process hasn't passed yet -- this process probably being
  'elabArgs'.
  - What form did the arguments have that are fed to 'apply'? What permits
    some of the holes getting filled at that stage already?
    - 'apply' doesn't take actual args at all? Just priorities and placeholder
      status? (!)
    - This filling is of course possible for those args that can be [inferred]
      automatically. Which I'm pretty sure I'm running into.
  - What form would this deferral take? Add a piece of info to each hole in
    'holes' in ProofState?
    - Would this simply be a Bool or would I need some more structure?
      - I imagine I *could* have a stack of info about what function
        applications we are in while elaborating, and have each hole 'tagged'
        with the application it was introduced in. Then, when deciding whether
        to solve a hole, we look at whether we are still elaborating the
        application that hole was introduced in, and will not solve if that
        is the case.
        - But is this necessary?
|
- No, it goes beyond that! Solving has to be blocked even for those holes
  that have 'been passed'! It's only safe to unify once all args have been
  checked for possible default insertion! (!!)

- Might I want to not do a full 'elabArgs' between the planned 'prepare_apply'
  and the not-yet-existent 'finish_apply', but something more limited? (!?)
  - This is probably not a thought that makes a lot of sense.

- Given the most recent note, should I dare to feel like I might suddenly be
  quite far into having finally solved this thing? :O

- [*After* the notes below:] Hmhm should we instead replace the call to
  'apply' with something like 'prepare_apply', or simply 'prepare_apply'
  itself? (!!?)
  - We'd then split out the 'post-prepare_apply' parts of 'apply' into its
    own function. (!)
|
- Should I do things by modifying 'apply', or is that overkill?
  - Is there a reasonable way to do otherwise?
    - Would it not be the case that we'd have to open another set of holes,
      which would be awkward given the already-still-partially-existing
      set of holes left over from apply?
|
- Or should I clone and modify 'apply' into an 'apply_with_defaults' or
  something? (!?)
|
- If I work by modifying 'apply', do I need to work with defaults before
  'fillt' is invoked? (!!?)

- Are we doing something possibly necessary in our elabArgs to turn the (in my
  recollection) PTerm-form default argument into something compatible with all
  the (TT-form) stuff handed over from 'apply'? (!?)
  - (Does this make any sense?)
  - It seems elabArgs basically works with PTerms/PArgs throughout, so I
    suppose the answer is no.

- Did I ever try to drop 'end_unify' from 'apply'? (!?)

- Where was (the relevant part of) 'my code' (see [(*)] below)?
  - In elabArgs?
    - Yeah, that is at least a significant part of it.

- Now, what was I doing before I had to yak-shave the NIX_PATH?
  - Aside from trying to get a stack/cabal repl to work so I could create tags?
    - What was I going to use tags for, btw? What code was I looking at? (!!)
      - Did it relate to the stack trace?
  - I was looking at some of the output from 'make'?
    - Or was it output from somewhere else?
  - Anyhow, the (recently modified) debug string with the env stuff.
    - See note below!
      - Let me pat myself on the back for having made useful notes for a
        change...

- Many notes here will be slightly or not-so-slightly confused and confusing,
  and may involve laborious attempts at recollecting relevant details of work
  that I did not have time to write down when I stopped in October 2015.
|
- In work after 5756c17b6066142de8ce79c8a6a8b4ee80a3527d, I get one of my
  debug messages while typechecking libs/prelude/Prelude/Nat.idr:
  env: [({__argTy104},Hole {binderTy = Type 0}),({iType102},Hole {binderTy = Type 0})] varn: {m510}.
  - Now, I'll try to remember things: What should I be presuming to be the
    role and origin of 'm510' here?
    - Was m510 a hole name for something that I expected to *still be* a hole,
      but is instead a hole that no longer exists?
      - What names do the holes created [in 'apply' [?]] get?
        - Judging from 'prepare_apply', names pretty much precisely like that
          'm510'!
      - I'm somewhat confident that it's from 'prepare_apply' in 'apply'.
        - But does that make sense? Should it be left over for my code [(*)]
          to confuse itself with, if the hole is closed *during apply*?
          - Maybe it isn't closed during 'apply', but some time after?
          - Find out whether 'apply' returns names of holes that were already
            closed!
            - 'end_unify' in 'apply' at least *closes* holes -- but are those
              hole names taken care of in the way that I'm assuming would make
              sense, i.e. left out from the list of hole names that 'apply'
              returns?
              - Does not seem so! (!!)
                - Or, hmmmh, does 'updateUnify' do exactly that?
          |
          - I had another thought as well. What was it?
            - Ah: How were 'ns' from 'apply' used before my changes, i.e. in
              'master'? Were those passed to elabArgs at all?
              - They *are* passed to elabArgs. Now, how are they used?
                - Each one is *only used if it's found among the actual holes
                  that still exist*! (!!!)
                |
                - I.e. many of them can well be useless!
                - (BTW what's the role of the 'argName's?) (!??)


---- Long, abrupt break -------


- Might it be ok to do 'refocus' on the next hole after each arg in elabArgs?
  That might be a thing I need to do? (!!)
  - See if elabArgs needs something specific with current proof term that'd
    conflict with this idea.
    - Looks like it doesn't?

- Are the 'hole names' from 'apply' reliable at all? How would we get the
  actual hole names? (!!)
  - Manually from the proof term?

- Does unifyProblems that's done before elabArgs get rid of the holes that we'd
  need? (!!!)
  - I removed it but things still fail.

- How might I make elabArgs successsfully use the hole names in the modified
  default argument? (!!!)

- Are the names from idris_implicits etc still usable at elabArgs, after
  the uniqueNames stuff that's been done?
  - Actually I get the impression that names already in context won't get
    touched.

- Return insertImpl to roughly what it was before the original default argument
  substitution patch? (!)
  - Rename insImpAcc to insertImpl' and remove any accumulation stuff?
|
- Do kind of what insImpAcc does now, but in elabArgs, and with the holes from
  'apply' instead of with the arg terms? (!)
|
- I suspect I'll want to modify things so that elabArgs does the required work,
  and gets the necessary info for doing so. (!!)
  - PArgs instead of PTerms?

- Reducible return types in a type declaration are only handled with TT info,
  so default arguments won't get filled into them even if something would
  otherwise reduce into an Idris Pi type with a default argument. (!)
  - So, I suppose that's a case I won't be dealing with anytime soon. (!)

- I already pondered where implicit args are added to args that themselves are
  applications: I think this happens in 'elabArgs' which is called some time
  after 'apply'.

- Huh. 'apply' in Idris/Core/Elaborate.hs just outputs param names and *names
  of their holes*! I suspect I can do stuff after apply is called in
  Idris/Elab/Term.hs (!!!)
  - https://github.com/idris-lang/Idris-dev/blob/0f89577db795eaa8c809e8247dba025b2652dc3c/src/Idris/Elab/Term.hs#L842
